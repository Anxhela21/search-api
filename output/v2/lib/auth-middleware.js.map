{"version":3,"sources":["../../../src/v2/lib/auth-middleware.js"],"names":["authorization","shouldLocalAuth","_","isEmpty","process","env","MOCK","SERVICEACCT_TOKEN","idToken","replace","Error","getKubeToken","usertoken","options","url","config","get","headers","Accept","Authorization","json","fullResponse","NODE_ENV","mockReq","nsResponse","Array","isArray","items","map","ns","metadata","name","getNamespaces","createAuthMiddleWare","asyncMiddleware","fn","req","res","next","Promise","resolve","catch","cache","max","maxAge","kubeToken","nsPromise","set","user","namespaces"],"mappings":";;;;;;AAqBA;AACA;AACA;AACA;;+BACA,WAA4B;AAC1BA,iBAD0B;AAE1BC;AAF0B,GAA5B,EAGG;AACD,QAAKC,iBAAEC,OAAF,CAAUH,aAAV,KAA4BC,eAA7B,IAAiDG,QAAQC,GAAR,CAAYC,IAAZ,KAAqB,MAA1E,EAAkF;AAChF;AACA;AACA,aAAOF,QAAQC,GAAR,CAAYE,iBAAZ,IAAiC,UAAxC;AACD;AACD,UAAMC,UAAUR,cAAcS,OAAd,CAAsB,SAAtB,EAAiC,EAAjC,CAAhB;AACA,QAAI,CAACD,OAAL,EAAc;AACZ,YAAM,IAAIE,KAAJ,CAAU,wDAAV,CAAN;AACD;;AAED,WAAOF,OAAP;AACD,G;;kBAfcG,Y;;;;;AAiBf;AACA;;;;gCACA,WAA6BC,SAA7B,EAAwC;AACtC,UAAMC,UAAU;AACdC,WAAM,GAAEC,iBAAOC,GAAP,CAAW,gBAAX,CAA6B,wCADvB;AAEdC,eAAS;AACP,wBAAgB,kBADT;AAEPC,gBAAQ,kBAFD;AAGPC,uBAAgB,UAASP,SAAU;AAH5B,OAFK;AAOdQ,YAAM,IAPQ;AAQdC,oBAAc;AARA,KAAhB;AAUA,QAAIjB,QAAQC,GAAR,CAAYiB,QAAZ,KAAyB,MAA7B,EAAqC;AACnC,YAAMC,UAAU,wBAAhB;AACA,aAAOA,QAAQV,OAAR,CAAP;AACD;AACD,UAAMW,aAAa,MAAM,uBAAQX,OAAR,CAAzB;AACA,WAAOY,MAAMC,OAAN,CAAcF,WAAWG,KAAzB,IAAkCH,WAAWG,KAAX,CAAiBC,GAAjB,CAAqB;AAAA,aAAMC,GAAGC,QAAH,CAAYC,IAAlB;AAAA,KAArB,CAAlC,GAAiF,EAAxF;AACD,G;;kBAjBcC,a;;;;;AAoBf;AACA;AACA;AACA;;;kBACwBC,oB;;AA3DxB;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;2cAbA;;;;;;;;;AAeA;AACA,MAAMC,kBAAkBC,MAAM,CAACC,GAAD,EAAMC,GAAN,EAAWC,IAAX,KAAoB;AAChDC,UAAQC,OAAR,CAAgBL,GAAGC,GAAH,EAAQC,GAAR,EAAaC,IAAb,CAAhB,EACGG,KADH,CACSH,IADT;AAED,CAHD,CAoDe,SAASL,oBAAT,CAA8B;AAC3CS,UAAQ,wBAAI;AACVC,SAAK,IADK;AAEVC,YAAQ,IAAI,EAAJ,GAAS,IAFP,CAEa;AAFb,GAAJ,CADmC;AAK3C3C;AAL2C,IAMzC,EANW,EAMP;AACN,SAAOiC;AAAA,kCAAgB,WAAOE,GAAP,EAAYC,GAAZ,EAAiBC,IAAjB,EAA0B;AAC/C,YAAM9B,UAAU,MAAMG,aAAa;AACjCX,uBAAeoC,IAAInB,OAAJ,CAAYjB,aAAZ,IAA6BoC,IAAInB,OAAJ,CAAYE,aADvB;AAEjClB;AAFiC,OAAb,CAAtB;AAIAmC,UAAIS,SAAJ,GAAgBrC,OAAhB;AACA;AACA;AACA,UAAIsC,YAAYJ,MAAM1B,GAAN,CAAW,cAAaR,OAAQ,EAAhC,CAAhB;AACA,UAAI,CAACsC,SAAL,EAAgB;AACdA,oBAAYd,cAAcxB,OAAd,CAAZ;AACAkC,cAAMK,GAAN,CAAW,cAAavC,OAAQ,EAAhC,EAAmCsC,SAAnC;AACD;AACDV,UAAIY,IAAJ,GAAW;AACT;AACAjB,cAAMvB,OAFG;AAGTyC,oBAAY,MAAMH,SAHT;AAITtC;AAJS,OAAX;;AAOA8B;AACD,KArBM;;AAAA;AAAA;AAAA;AAAA,OAAP;AAsBD","file":"auth-middleware.js","sourcesContent":["/** *****************************************************************************\n * Licensed Materials - Property of IBM\n * (c) Copyright IBM Corporation 2019. All Rights Reserved.\n *\n * Note to U.S. Government Users Restricted Rights:\n * Use, duplication or disclosure restricted by GSA ADP Schedule\n * Contract with IBM Corp.\n ****************************************************************************** */\n\nimport _ from 'lodash';\nimport lru from 'lru-cache';\nimport config from '../../../config';\nimport createMockIAMHTTP from '../mocks/iam-http';\nimport request from './request';\n\n// Async middleware error handler\nconst asyncMiddleware = fn => (req, res, next) => {\n  Promise.resolve(fn(req, res, next))\n    .catch(next);\n};\n\n// Get a Kubernetes token from the authorization token.\n// - When the actor is a user we receive an access_token, and exchange it for an id_token.\n// - When the actor is a service id, there isn't a Kubernetes token, so we use the\n//   service account token. This is only possible if the service id role is ClusterAdmin.\nasync function getKubeToken({\n  authorization,\n  shouldLocalAuth,\n}) {\n  if ((_.isEmpty(authorization) && shouldLocalAuth) || process.env.MOCK === 'true') {\n    // special case for graphiql to work locally\n    // do not exchange for idtoken since authorization header is empty\n    return process.env.SERVICEACCT_TOKEN || 'localdev';\n  }\n  const idToken = authorization.replace('Bearer ', '');\n  if (!idToken) {\n    throw new Error('Authentication error: invalid token parsed from cookie');\n  }\n\n  return idToken;\n}\n\n// Get the namespaces authorized for the access_token.\n// usertoken - could be from a user or service id.\nasync function getNamespaces(usertoken) {\n  const options = {\n    url: `${config.get('API_SERVER_URL')}/apis/project.openshift.io/v1/projects`,\n    headers: {\n      'Content-Type': 'application/json',\n      Accept: 'application/json',\n      Authorization: `Bearer ${usertoken}`,\n    },\n    json: true,\n    fullResponse: false,\n  };\n  if (process.env.NODE_ENV === 'test') {\n    const mockReq = createMockIAMHTTP();\n    return mockReq(options);\n  }\n  const nsResponse = await request(options);\n  return Array.isArray(nsResponse.items) ? nsResponse.items.map(ns => ns.metadata.name) : [];\n}\n\n\n// Middleware to:\n// - Set namespaces to filter this request.\n// - Set user for the request\n// - Set token for kubernetes requests.\nexport default function createAuthMiddleWare({\n  cache = lru({\n    max: 1000,\n    maxAge: 2 * 60 * 1000, // 2 mins. Must keep low because user's permissions can change.\n  }),\n  shouldLocalAuth,\n} = {}) {\n  return asyncMiddleware(async (req, res, next) => {\n    const idToken = await getKubeToken({\n      authorization: req.headers.authorization || req.headers.Authorization,\n      shouldLocalAuth,\n    });\n    req.kubeToken = idToken;\n    // Get the namespaces for the user.\n    // We cache the promise to prevent starting the same request multiple times.\n    let nsPromise = cache.get(`namespaces_${idToken}`);\n    if (!nsPromise) {\n      nsPromise = getNamespaces(idToken);\n      cache.set(`namespaces_${idToken}`, nsPromise);\n    }\n    req.user = {\n      // temporarily using the idToken as userName until we figure out how to exchange token for name\n      name: idToken,\n      namespaces: await nsPromise,\n      idToken,\n    };\n\n    next();\n  });\n}\n"]}