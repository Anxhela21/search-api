{"version":3,"sources":["../../../src/v2/models/application.js"],"names":["groupByStatus","resources","statusKey","result","forEach","r","AppModel","constructor","searchConnector","checkSearchServiceAvailable","isServiceAvailable","logger","error","Error","runQueryOnlyOnce","searchConnectorQueryName","queryFn","Promise","reject","resolveApplications","name","namespace","apps","runApplicationsQuery","filter","app","warn","resolveAppClustersCount","appUid","clusters","c","find","count","resolveAppHubSubscriptions","subs","s","resolveAppPodsCount","pods","p","resolveAppRemoteSubscriptions","resolveGlobalAppChannelsCount","ch","runGlobalAppChannelsQuery","length","resolveGlobalAppClusterCount","runGlobalAppClusterCountQuery","resolveGlobalAppHubSubscriptionsCount","runGlobalAppHubSubscriptionsQuery","resolveGlobalAppRemoteSubscriptions","runGlobalAppRemoteSubscriptionsQuery"],"mappings":"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","file":"application.js","sourcesContent":["/** *****************************************************************************\n * Licensed Materials - Property of IBM\n * (c) Copyright IBM Corporation 2019. All Rights Reserved.\n *\n * Note to U.S. Government Users Restricted Rights:\n * Use, duplication or disclosure restricted by GSA ADP Schedule\n * Contract with IBM Corp.\n ****************************************************************************** */\n\nimport { isRequired } from '../lib/utils';\nimport logger from '../lib/logger';\n\n/*\n * Format results grouping by status.\n * Sample output:\n *   {\n *     ContainerCreating: 1,\n *     Running: 3,\n *   }\n */\nfunction groupByStatus(resources, statusKey) {\n  const result = {};\n  resources.forEach((r) => {\n    if (result[r[statusKey]]) {\n      result[r[statusKey]] += 1;\n    } else {\n      result[r[statusKey]] = 1;\n    }\n  });\n  return result;\n}\n\nexport default class AppModel {\n  constructor({ searchConnector = isRequired('searchConnector') }) {\n    this.searchConnector = searchConnector;\n  }\n\n  checkSearchServiceAvailable() {\n    if (!this.searchConnector.isServiceAvailable()) {\n      logger.error('Unable to resolve search request because Redis is unavailable.');\n      throw Error('Search service is unavailable');\n    }\n  }\n\n  /*\n   * An instance of AppModel is created for every API request.\n   * This is used for queries that run only once, for example, when\n   * resolving an application list, we'll resolve subscriptions only once\n   * for all applications, then use the same result for each app resolver.\n   */\n  async runQueryOnlyOnce(searchConnectorQueryName) {\n    await this.checkSearchServiceAvailable();\n    const queryFn = this.searchConnector[searchConnectorQueryName];\n    if (queryFn && typeof queryFn === 'function') {\n      if (!this[`${searchConnectorQueryName}Promise`]) {\n        this[`${searchConnectorQueryName}Promise`] = this.searchConnector[searchConnectorQueryName]();\n      }\n      return this[`${searchConnectorQueryName}Promise`];\n    }\n    logger.error('Expected to recive a function.', queryFn, searchConnectorQueryName);\n    return Promise.reject(new Error('Expected to recive a function.'));\n  }\n\n  /*\n   * Resolve Applications.\n   * This is more efficient than searching for `kind:application`\n   */\n  async resolveApplications({ name, namespace }) {\n    await this.checkSearchServiceAvailable();\n\n    if (name != null && namespace != null) {\n      const apps = await this.searchConnector.runApplicationsQuery();\n      return apps.filter(app => (app['app.name'] === name && app['app.namespace'] === namespace));\n    } else if (name == null || namespace == null) {\n      logger.warn('To filter applications must you provide both name and namespace. Returning all apps.');\n    }\n\n    return this.searchConnector.runApplicationsQuery();\n  }\n\n  /*\n   * For a given application, return the number of clusters where it has resources.\n   */\n  async resolveAppClustersCount(appUid) {\n    const clusters = await this.runQueryOnlyOnce('runAppClustersQuery');\n    const c = clusters.find(app => app['app._uid'] === appUid);\n    return c ? c.count : 0;\n  }\n\n  /*\n   * For a given application, resolve the hub subscriptions.\n   */\n  async resolveAppHubSubscriptions(appUid) {\n    const subs = await this.runQueryOnlyOnce('runAppHubSubscriptionsQuery');\n    return subs.filter(s => s['app._uid'] === appUid);\n  }\n\n  /*\n   * For a given application, resolve the pod count, grouped by status.\n   */\n  async resolveAppPodsCount(appUid) {\n    const pods = await this.runQueryOnlyOnce('runAppPodsCountQuery');\n    return groupByStatus(pods.filter(p => p['app._uid'] === appUid), 'pod.status');\n  }\n\n  /*\n   * For a given application, resolve the mote subscriptions, grouped by status.\n   */\n  async resolveAppRemoteSubscriptions(appUid) {\n    const subs = await this.runQueryOnlyOnce('runAppRemoteSubscriptionsQuery');\n    return groupByStatus(subs.filter(s => s['app._uid'] === appUid), 'sub.status');\n  }\n\n  /* ***  GLOBAL APPLICATION DATA RESOLVERS *** */\n\n  /*\n   * Number of channels associated to any application.\n   */\n  async resolveGlobalAppChannelsCount() {\n    const ch = await this.searchConnector.runGlobalAppChannelsQuery();\n    return ch.length;\n  }\n\n  /*\n   * Number of clusters where any application has resources.\n   */\n  async resolveGlobalAppClusterCount() {\n    const clusters = await this.searchConnector.runGlobalAppClusterCountQuery();\n    return clusters.length;\n  }\n\n  /*\n   * Number of hub subscriptions associated to any application.\n   */\n  async resolveGlobalAppHubSubscriptionsCount() {\n    const subs = await this.searchConnector.runGlobalAppHubSubscriptionsQuery();\n    return subs.length;\n  }\n\n  /*\n   * Remote subscriptions associated to any application. Grouped by state.\n   */\n  async resolveGlobalAppRemoteSubscriptions() {\n    const subs = await this.searchConnector.runGlobalAppRemoteSubscriptionsQuery();\n    return groupByStatus(subs, 'sub.status');\n  }\n}\n"]}